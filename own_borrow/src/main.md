描述 rust 里面的所有权和借用。

# 所有权

我们经常能够听到这样的说法，rust 是内存安全的。怎么做到的呢？像其他编程语言，可以同时有多个栈对象指向堆内存，通过 GC 或者 手动释放的方式来管理内存。这么做的代价就是要么性能差要么内存不安全(内存泄漏、double free、
悬垂指针等)。

那么 rust 是怎么做的呢？

只能有一个栈对象指向堆内存，当栈对象生命期结束的时候，释放堆内存。这种指向关系，就是所有权。

在 rust 中的变量赋值、函数入参、函数返回值，默认都是 Move 语义，即所有权转让。这里的 Move 跟 c++ 里面的 move 语义是很相似的，即资源的转让。

如果要更改这种默认的方式，可以使用 copy or clone 语义。

- copy

    copy 即浅拷贝，位级复制。move 也是浅拷贝，不同的是，move 语义中，原对象被 reset，copy 语义中，原对象不发生任何变化。

    这里有个问题，按照上面的描述，copy 语义下，岂不是有可能会存在两个栈对象同时指向同一个堆对象？这不就内存不安全了吗？

    **不是所有类型都支持 copy 语义！**

    那么什么类型可以 copy 呢？

    一个基本的原则是：**任何基本类型以及基本类型的组合可以 copy, 不需要资源(内存、其他类型资源) 的类型也是可以 copy 的.**

    但是需要注意的是，可变引用类型是不支持 copy 语义的，这是为什么呢？我们在引用小节来描述这个问题。

- clone

    clone 就是深拷贝，类似 c++ 中的拷贝构造函数。新对象获得一份旧对象的深度拷贝。在 rust 中，通过 `clone()` 方法来实现深度拷贝。

    通常在程序中，很少会用到深拷贝，绝大多数场景就是浅拷贝。

# 引用 & 借用

引用就是借用。为什么要存在引用？有时候，我们并不像转移所有权，但也不想使用 copy/clone 语义，怎么办呢？这就是引用/借用。

引用本质上就是取原始变量的地址，类似 c/c++ 中的指针变量。

- 可变引用

    rust 的安全除了内存安全还包括并发安全。解决并发安全的一种很重要的方法就是任何时候，最多只能存在一个有效的可变引用。这样就避免了同时写、写读导致的数据不一致问题。

    我们需要了解一个重要的概念：引用的作用域。引用类型的变量的作用域跟普通的变量的作用域是不一样的。

    普通变量的作用域: [变量的定义, 最近的 '}' ]

    引用的作用域: [变量的定义， 变量最后一次使用], 我们把编译器的这种优化称为 **NLL**

    ```rust
    
    fn main() {
        let x = 5;              // x 开始
                                
        let y = &x;             // y 开始
                                
        println!("{}", y);      // y 结束
    } // x 结束 
    ```

    在了解了作用域这个概念后，我们来看看 rust 中只能存在一个可变引用的限制是什么样的。

    这里的一个可变引用值的是：**任何时候， 不可变或者可变引用的作用域不能有交集**。

    我们举几个例子：

    - 1
    
    编译通过。
    ```rust
    fn main() {
        let mut x = 10;

        let ref1 = &mut x; // ref1 作用域

        let ref2 = &mut x; // ref2 开始

        *ref2 = 1;          // ref2 结束

        println!("{}", x);
    }
    ```
    - 2

    我们仅需要堆上述例子进行一个小小的变更，便会触发编译错误。

    ```rust
    fn main() {
        let mut x = 10;

        let ref1 = &mut x; // ref1 开始

        let ref2 = &mut x; // ref2 开始、结束。

        *ref1 = 1; // ref1 结束。 显然 ref1 跟 ref2 的作用域像交，因此在交集的区域内，同时存在多个可便引用，这显然是不允许的。

        println!("{}", x);
    }
    ```

    - 3

    同样，可变/不可变引用的作用域也不能相交。
    同样，对例子 2 进行一个小小的变更，便会触发新的编译错误。

    ```rust
    fn main() {
        let mut x = 10;

        let ref1 = &mut x;  // ref1 开始

        let ref2 = &x;  // ref2 只读引用

        *ref1 = 1;  // ref1 结束。显然 ref1 跟 ref2 相交，同时读写，这是不允许的。

        println!("{}", x);
    }
    ```

- 解引用

    - 不能通过解引用来 Move，不过如果实现了 Copy Trait 的类型，是可以通过解引用将对象拷贝给其他对象的。
    